<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <!-- 
      首先一点，JavaScript是一门单线程非阻塞的语言，只是由于它最初的用途是与浏览器交互，
      单线程意味着，JS代码在执行时，只有一个主线程来处理所有任务。
      非阻塞则是当代码需要进行一项异步任务时，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调
      PS:node环境中也存在与浏览器相似的时间循环体系，但有诸多不同。
      
      1、执行栈与事件队列
      1.1同步
      JS代码执行时会把不同的变量存于内存中的不同位置：堆（heap）和栈（stack）中来加以区分。其中堆中存放一些对象，而栈中存放基础类型变量以
      及对象的指针。但执行栈和栈是有区别的。

      当我们调用一个方法时，JS会生成一个与之对应的执行环节context，又称执行上下文。这个执行环境中存在着这个方法的私有作用域(this对象)。而当
      一系列方法被依次调用的时候，因为JS是单线程，同一时间只能执行一个方法，于是那些方法被排队在一个单独的地方，称之为执行栈。

      一个方法的执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法甚至是自己，就是往执行栈中添加另一个执行环境。这个
      过程可以无限进行，除非发生栈溢出。
      
      1.2异步
      因为JS非阻塞的特点，JS在执行异步代码时会遵循事件队列机制，来实现非阻塞的特性。
      JS遇到一个异步事件后不会一直等待其结果返回，而是会挂起这个事件，然后继续执行执行栈中的其余任务。直到异步事件返回结果，JS会将异步函数回
      调事件加入与当前执行栈不同的一个队列，我们称之为事件队列。被放入事件队列不会立即执行回调，而是等待当前执行栈中的所有任务执行完毕，直到主线
      程处于闲置状态时，它才会去查找事件队列中是否还有异步回调去执行，如果有主线程会从中取出排在第一位的事件，并把这个对应的回调函数放入执行栈中
      然后执行其中的同步代码，如此反复形成一个无限循环，这就是为什么这个过程被称之为“事件循环”。
      
      PS:事件队列扩展
      上述只是宏观事件循环的一个表述过程，而不同异步任务之间的执行优先级也是有所区别的。不同异步任务被分为两类：微任务（micro task）、宏任务（macro task）
      *以下事件属于宏任务：
        setInterval()
        setTimeout()
      *以下事件属于微任务
        Promise.resolve().then()
        new MutationObserver()
      当当前执行栈执行完毕时会立即优先处理微任务队列中的事件，然后再去执行宏任务队列中的事件。同一次事件循环中，微任务永远在宏任务之前执行。
      
     -->
    <script>
      // setTimeout(function () {
      //   console.log(1)
      // })
      // new Promise(function (resolve, reject) {
      //   console.log(2)
      //   resolve(3)
      // }).then(function (val) {
      //   console.log(val)
      // })
      // console.log(4)
      // 结果
      // 2
      // 4
      // 3
      // 1
    </script>
  </body>
</html>
